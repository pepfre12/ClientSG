local script = game:GetObjects("rbxassetid://15670878040")[1].Convert
game:GetObjects("rbxassetid://14580326479")


--[[

by QSparkedDreemurr/SparkedDreemurr/QSparkes

yes i have alot of accounts.

dont leak this or ill pound you to a pulp.
i spent a while on this.

]]

local plr=game.Players.LocalPlayer
local char=plr.Character
local mouse=plr:GetMouse()
local hum=char:waitForChild("Humanoid")
local tors=char:waitForChild("Torso")
local root=char:waitForChild("HumanoidRootPart")
local effects=Instance.new("Folder",char)

local head=char.Head

local pants=Instance.new("Pants")
local shirt=Instance.new("Shirt")

local newSc=Instance.new("Folder",game.Lighting)
newSc.Name=plr.UserId

local RScript=script

for i,v in pairs(script:children())do v.Parent=newSc end

getfenv().script=newSc

local rsO=CFrame.new(1, 0.5, 0) * CFrame.Angles(0, 1.571, 0)
local rsO1=CFrame.new(-0.5, 0.5, 0) * CFrame.Angles(0, 1.571, 0)
local lhO=CFrame.new(-1, -1, 0) * CFrame.Angles(0, -1.571, 0)
local lhO1=CFrame.new(-0.5, 1, 0) * CFrame.Angles(0, -1.571, 0)
local rhO=CFrame.new(1, -1, 0) * CFrame.Angles(0, 1.571, 0)
local rhO1=CFrame.new(0.5, 1, 0) * CFrame.Angles(0, 1.571, 0)
local lsO=CFrame.new(-1, 0.5, 0) * CFrame.Angles(0, -1.571, 0)
local lsO1=CFrame.new(0.5, 0.5, 0) * CFrame.Angles(0, -1.571, 0)
local nec=CFrame.new(0, 1, 0) * CFrame.Angles(-1.571, 0, -3.142)
local nec1= CFrame.new(0, -0.5, 0) * CFrame.Angles(-1.571, 0, -3.142)
local rjO=CFrame.new(0, 0, 0) * CFrame.Angles(-1.571, 0, -3.142)


local ang=CFrame.Angles
local cf=CFrame.new
local rad=math.rad
local rnd=math.random
local cos=math.cos
local sin=math.sin
local it=Instance.new
local vt=Vector3.new

function clerp(a,b,t)return a:lerp(b,t)end
function tween(obj,prop,tween,dir,val,speed) game:GetService("TweenService"):create(obj,TweenInfo.new(speed,Enum.EasingStyle[tween or "Linear"],Enum.EasingDirection[dir or "Out"]),{[prop]=val}):play()end
function swait(n)if n==nil or n==0 then game:GetService("RunService").Heartbeat:wait() else for i=1,n do game:GetService("RunService").Heartbeat:wait() end end end
function sphereEff(pos,col,size,speed,bonus,bonusSpeed,spread) local ring=it("Part") local msh=it("SpecialMesh") ring.Parent=effects ring.Color=col ring.Name="Ring" ring.Material="Neon" ring.CanCollide=false ring.Position=pos ring.Anchored=true ring.Size=Vector3.new(.1,.1,.1) msh.Parent=ring msh.MeshType="Sphere" tween(msh,"Scale","Quad","InOut",size*10,speed+(bonus/2)-bonusSpeed)if spread then tween(msh,"Offset","Linear","Out",vt(0,size.Y/1.4+spread,0),speed+bonus)end tween(ring,"Transparency","Linear","Out",1,speed+bonus) game.Debris:AddItem(ring,speed+bonus+.1) return ring end 
function sound(id,par,vol,loop) local snd=it("Sound",par) snd.Volume=vol snd.Looped=loop snd.SoundId="rbxassetid://"..tostring(id)snd:play() spawn(function()repeat wait() until snd.IsPlaying==false snd:destroy()end)return snd end
function propell(tar,studs)tween(tar.HumanoidRootPart,"CFrame","Linear","Out",tar.HumanoidRootPart.CFrame*cf(0,0,studs),.2)tar.HumanoidRootPart.Anchored=true wait(.2)tar.HumanoidRootPart.Anchored=false end
function hbax2(time,dmg,pos,siz)local new=it("Part",effects)new.Name="hbox" new.Transparency=1 new.CanCollide=false new.Anchored=true new.Size=Vector3.new(siz,siz,siz) new.Position=pos new.Touched:connect(function(hit) if hit.Parent:findFirstChildOfClass"Humanoid" and hit.Parent~=char then hit.Parent:findFirstChildOfClass"Humanoid":takeDamage(dmg) wait() new:destroy() end end) game.Debris:AddItem(new,time) end
function hbax(time,dmg)local new=it("Part",effects)new.Name="hbox" new.Transparency=1 new.CanCollide=false new.Anchored=true new.Size=Vector3.new(4,4,4) new.CFrame=root.CFrame*cf(0,0,-2) new.Touched:connect(function(hit) if hit.Parent:findFirstChildOfClass"Humanoid" and hit.Parent~=char then hit.Parent:findFirstChildOfClass"Humanoid":takeDamage(dmg) wait() new:destroy() end end) game.Debris:AddItem(new,time) end
function ezWeld(par,no)local sc=script.Weld:clone()sc.Parent=par sc.leave.Value=no or""sc.Disabled=false end
function weld(p0,p1,c0,c1,par)local w = Instance.new("Weld", par)w.Part0 = p0 w.Part1 = p1 w.C0 = c0 or CFrame.new() w.C1 = c1 or CFrame.new()return w end
function sphereEff2(pos,col,size,speed,bonus) local ring=it("Part") local msh=it("SpecialMesh") ring.Parent=effects ring.Size=Vector3.new(.1,.1,.1) ring.CanCollide=false ring.Anchored=true ring.Position=pos ring.Color=col ring.Material="Neon" msh.Parent=ring msh.MeshType="Sphere" tween(msh,"Scale","Quad","InOut",size*10,speed+(bonus/2)) tween(ring,"Transparency","Linear","Out",1,speed+bonus) game.Debris:AddItem(ring,speed+bonus+.1) return ring end
function shakee(pwr,dur)for i,v in pairs(game.Players:children())do local sc=script.ShakeScript:clone() sc.Parent=v.PlayerGui sc.pwr.Value=pwr sc.dur.Value=dur sc.Disabled=false end end
function singleShake(plr,pwr,dur)local sc=script.ShakeScript:clone() sc.Parent=game.Players[plr].PlayerGui sc.pwr.Value=pwr sc.dur.Value=dur sc.Disabled=false end



shirt.ShirtTemplate=""
pants.PantsTemplate=""
shirt.Parent=char
pants.Parent=char

--[[local ls=tors:waitForChild("Left Shoulder")
local rs=tors:waitForChild("Right Shoulder")
local lh=tors:waitForChild("Left Hip")
local rh=tors:waitForChild("Right Hip")
local ne=tors:waitForChild("Neck")
local rj=root:waitForChild("RootJoint")]]

local ls=weld(tors,char["Left Arm"],lsO,lsO1,char)
local rs=weld(tors,char["Right Arm"],rsO,rsO1,char)
local lh=weld(tors,char["Left Leg"],lhO,lhO1,char)
local rh=weld(tors,char["Right Leg"],rhO,rhO1,char)
local ne=weld(tors,head,nec,nec1,char)
local rj=weld(root,tors,rjO,rjO,char)
local attack=false
local RW=rs
local LW=ls
local RH=rh
local LH=lh
local RootPart=root
local RootJoint=rj
local Torso=tors
local RootCF=rjO
local necko=nec
local angles=ang
local Character=char
local rootPart=root
local Neck=ne
local Right_Shoulder=rs
local Left_Shoulder=ls
local Right_Hip=rh
local Left_Hip=lh
local rootJoint=rj
local Right_Arm=char["Right Arm"]
local Left_Arm=char["Left Arm"]	
local LA_Weld=ls
local RA_Weld=rs
local Torso_Weld=rj
local Head_Weld=ne
local LL_Weld=lh
local Head=head
local RL_Weld=rh
local Right_Leg=char["Right Leg"]
local Left_Leg=char["Left Leg"]		

ruin=BrickColor.new("Really red")
counter=0
function bosschat(text)
	for i,v in pairs(game.Players:children())do
		local function unpack(plr)
			local gui=script.Bosschat.ChatFunc:clone()
			gui.Parent=plr.PlayerGui
			gui.txt.Value=text
			gui.LocalScript.Disabled=false
		end
		unpack(v)
	end
end

function chatfunc(text)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("textboard")~= nil then
			char:FindFirstChild("textboard"):destroy()
		end
		if char:FindFirstChild("glitchboard")~= nil then
			char:FindFirstChild("glitchboard"):destroy()
		end
		local naeeym2 = script.textboard:Clone()
		naeeym2.Parent = char
		naeeym2.StudsOffset = Vector3.new(0,3,0)
		naeeym2.Adornee = head
		naeeym2.Enabled = true
		local naeeym3 = script.glitchboard:Clone()
		naeeym3.Parent = char
		naeeym3.StudsOffset = Vector3.new(0,3,0)
		naeeym3.Adornee = head
		naeeym3.Enabled = true
		local tecks2 = naeeym2.TextLabel
		tecks2.Text = ""
		for i = 1,string.len(text),1 do
			local heh =sound(434975206, head, 5, false)
			tecks2.Text = "* "..string.sub(text,1,i)
			if i ~= string.len(text) then
				local ADD = string.sub(text,i,i)
				if ADD == "." or ADD == "?" or ADD == "!" then
					wait(0.4)
				elseif ADD == "," then
					wait(0.2)
				else
				end
			end

			wait(0.01)
		end

		wait(2)
		naeeym2:Destroy()
		naeeym3:Destroy()
	end)
	chat()
end
function chatfunc2(text)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("textboard")~= nil then
			char:FindFirstChild("textboard"):destroy()
		end
		if char:FindFirstChild("glitchboard")~= nil then
			char:FindFirstChild("glitchboard"):destroy()
		end
		local naeeym2 = script.textboard:Clone()
		naeeym2.Parent = char
		naeeym2.StudsOffset = Vector3.new(0,3,0)
		naeeym2.Adornee = head
		naeeym2.Enabled = true
		local naeeym3 = script.glitchboard:Clone()
		naeeym3.Parent = char
		naeeym3.StudsOffset = Vector3.new(0,3,0)
		naeeym3.Adornee = head
		naeeym3.Enabled = true
		local tecks2 = naeeym2.TextLabel
		tecks2.Text = ""
		for i = 1,string.len(text),1 do
			local heh =sound(428072468, head, 5, false)
			tecks2.Text = "* "..string.sub(text,1,i)
			if i ~= string.len(text) then
				local ADD = string.sub(text,i,i)
			end

			wait(0.125)
		end

		wait(2)
		naeeym2:Destroy()
		naeeym3:Destroy()
	end)
	chat()
	wait(2)
end
plr.Chatted:connect(chatfunc)
plr.Chatted:connect(bosschat)

plr.Chatted:connect(function(msg)
	if msg:lower()=="/morph" then
		require(5344632187)(char,script.Frisk,false)
	end
end)

local song=4282352615

local theme=sound(song,char,1,true)
theme.Name="mus_"
ws=16



script.HealthBar.Parent=head
head.HealthBar.Frame.PName.Text=plr.Name

function smash(type,pos,tar)
	if type=="circ"then
		for i=1,80 do
			local new=Instance.new("Part",workspace)
			local hit,hitPos= workspace:FindPartOnRayWithIgnoreList(Ray.new(vt(pos.X,pos.Y,pos.Z)+vt(0,4,0),Vector3.new(0,-2048,0)),{char,new,tar})			
			new.Name="effect"
			new.Anchored=true
			new.Material=hit.Material 
			new.Color=hit.Color
			new.BackSurface=hit.BackSurface
			new.FrontSurface=hit.FrontSurface
			new.BottomSurface=hit.BottomSurface
			new.TopSurface=hit.TopSurface
			new.LeftSurface=hit.LeftSurface
			new.RightSurface=hit.RightSurface
			new.Size=Vector3.new(7,7, 7)
			game.Debris:AddItem(new,20)
			new.CFrame=pos*ang(0,rad(i*14),0)*cf(22,0,0)*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
		end
	end
end




function lerp(obj,cf,per)obj.C0=obj.C0:lerp(cf,per)end
function newObj(name)return script[name]:clone()end

local neck=ne
local V3={N=vt}


function teleport()
	local ray = nil
	ray = Ray.new(char.Torso.CFrame.p, (mouse.Hit.p - char.Torso.CFrame.p).unit * 100)
	local part, pos = workspace:FindPartOnRay(ray, char, false, true)
	char.HumanoidRootPart.CFrame = CFrame.new(pos.X,pos.Y,pos.Z) * CFrame.new(0,2,0)	
	sound(462606062,char.Torso,1,false)
	for i = 1,24 do
		local eff=sphereEff(root.Position,ruin.Color,Vector3.new(.3,6.8,.3),.225,.7,.5,15)
		eff.CFrame=eff.CFrame*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
	end
	root.CFrame=cf(root.CFrame.p, vt(mouse.Hit.X, root.CFrame.p.Y, mouse.Hit.Z))	
end


function refit()
	rootJoint.Parent = rootPart
	Neck.Parent = Torso
	Right_Shoulder.Parent = Torso
	Left_Shoulder.Parent = Torso
	Right_Hip.Parent = Torso
	Left_Hip.Parent = Torso
	rootPart.Parent = Character
	Left_Arm.Parent = Character
	Right_Arm.Parent = Character
	LA_Weld.Parent = Left_Arm
	RA_Weld.Parent = Right_Arm
	Torso_Weld.Parent = Torso
	Head_Weld.Parent = Head
	LL_Weld.Parent = Left_Leg
	RL_Weld.Parent = Right_Leg
	Right_Leg.Parent = Character
	Left_Leg.Parent = Character
	Torso.Parent = Character
	Head.Parent = Character
	ne.Parent=tors
end
local emitter = Instance.new("ParticleEmitter")
emitter.Name = "Dust"
emitter.LightEmission = 1
emitter.Transparency = NumberSequence.new(0,1)
emitter.Size = NumberSequence.new(0,0.2)
emitter.SpreadAngle = Vector2.new(360,360)
emitter.Speed = NumberRange.new(0.5)
emitter.Lifetime = NumberRange.new(0.75)
emitter.Texture = "rbxassetid://241812810"
emitter.Rate = 1000
emitter.Color = ColorSequence.new(Color3.new(1,1,1))
emitter.LockedToPart = false
function dustyBoi(prt)emitter:clone().Parent=prt end


ea=false
ph=0
c_new=cf
c_angles=ang


IN=Instance.new

function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = (material or Enum.Material.SmoothPlastic)
	part.TopSurface,part.BottomSurface=10,10
	part.Size = (size or V3.N(1,1,1))
	part.CFrame = (cframe or CF.N(0,0,0))
	part.Anchored = (anchored or false)
	part.CanCollide = (cancollide or false)
	part.Parent = (parent or Char)
	return part
end
function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

Char=char
CF={N=cf,A=ang}
C3={N=Color3.new}
function zigzag(X) return math.acos(math.cos(X*math.pi))/math.pi end

function rainbowF(obj)
	obj.Color = Color3.fromHSV(zigzag(counter),1,1) 	
	spawn(function()
		while true do
			swait()
			if rainbow then
				obj.Color = Color3.fromHSV(zigzag(counter),1,1)
			end 
		end
	end)
end
function rainbow2(obj)
	spawn(function()
		while true do
			swait()
			if rainbow then			
				obj.TextColor3 = Color3.fromHSV(zigzag(counter),1,1) 
			end
		end
	end)
end
function rainbow3(obj)
	spawn(function()
		while true do
			swait()
			if rainbow then			
				obj.Color = ColorSequence.new(Color3.fromHSV(zigzag(counter),1,1))
			end
		end
	end)
end
function rainbowCustom(obj,type)
	return Color3.fromHSV(zigzag(counter),1,1)
end


local respawning = false
local Deaths = 0

candie=false
Humanoid=hum
Humanoid.Died:Connect(function()
	--[[if candie == false then
		if respawning == false then
			respawning = true
			Humanoid.Parent = nil
			Humanoid.MaxHealth=math.huge
			Humanoid.Health=math.huge
			refit()
			Humanoid.Parent = Character
			--sound(2783295579, Head, 7, false)
			--chatfunc("D-Did you just wound me?!")
			glove1:destroy()
			glove2:destroy()
			glove1,glove2=script.glove:Clone(),script.glove:Clone()
			mid=script.mid:clone()
			ezWeld(glove1)
			ezWeld(glove2)
			ezWeld(mid)
			weld(tors,mid.middle,cf(),cf(),mid)
			weld(Left_Arm,glove1.middle,cf(),cf(),glove1)
			weld(Right_Arm,glove2.middle,cf(),cf(),glove2)
			
			glove1.Parent,glove2.Parent=char,char
			mid.Parent=char
			pcall(function()shs:Destroy()end)
			shs=script.SHS:clone()
			shs.Parent=char
			shs.MAINWELD.Part0=root
			shsO=shs.MAINWELD.C0
		
			glove1.Parent,glove2.Parent=char,char		
			Deaths = Deaths + 1
			respawning = false
		end	
	end]]	tag.Enabled=false
	spawn(function()
		for i=0,1.5,.01 do
			swait()
			theme.Pitch=theme.Pitch-.01
		end
	end)		Heart=script.Heart
	BrokenHeart=script.BrokenHeart
	spawn(function()
		local parts = char:GetDescendants()
		for l = 1, #parts do
			local v=parts[l]
			if parts[l]:isA"BasePart"or parts[l]:isA"Decal"and v~=Heart and v~=BrokenHeart then
				pcall(function()
					parts[l].CanCollide = false
					parts[l].Anchored = true
				end)	
				spawn(function()
					repeat wait()
						parts[l].Transparency = parts[l].Transparency + 0.1
					until parts[l].Transparency >= 1
				end)

			end
		end
	end)
	-----------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------
	local UppTor = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")

	local HeartClone = Heart:Clone()
	HeartClone.Parent = char
	HeartClone.CFrame = UppTor.CFrame
	HeartClone.Color=ruin.Color
	if rainbow then
		rainbowF(HeartClone)
	end
	wait(0.1)

	local OrigianlHeartPos = HeartClone.CFrame
	for i = 1,20 do
		wait()
		HeartClone.CFrame = CFrame.new(OrigianlHeartPos.X+math.random(-1,1)/10,OrigianlHeartPos.Y+math.random(-1,1)/10,OrigianlHeartPos.Z+math.random(-1,1)/10)
	end
	HeartClone:Destroy()

	local BrokenHeartClone = BrokenHeart:Clone()
	BrokenHeartClone.Parent = char
	BrokenHeartClone.CFrame = OrigianlHeartPos
	BrokenHeartClone.Separate:Play()
	BrokenHeartClone.Color=ruin.Color
	if rainbow then
		rainbowF(BrokenHeartClone)
	end

	wait(1.2)
	BrokenHeartClone.Transparency = 1

	for i = 1,math.random(6,8) do
		local newpart = Instance.new("Part", char)
		newpart.Size = Vector3.new(math.random(15,25)/100,math.random(15,25)/100,math.random(15,25)/100)
		newpart.CFrame = BrokenHeartClone.CFrame
		newpart.Color = BrokenHeartClone.Color
		newpart.Material = BrokenHeartClone.Material
		newpart.CanCollide = false

		newpart.Velocity = Vector3.new(math.random(-15,15),math.random(-5,25),math.random(-15,15))
		newpart.RotVelocity = Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))

		local BodyForce = Instance.new("BodyForce", newpart)
		BodyForce.Force = Vector3.new(0,newpart:GetMass()*170,0)
	end
end)


--theme.Pitch=1.12
alph=.09325

shs=script.SHS:clone()
shs.Parent=char
shs.MAINWELD.Part0=root
shsO=shs.MAINWELD.C0
Animation_Speed=4
intro=false
--[[spawn(function()
	intro=true
	for i=1,.1,.05 do
		swait()
		lerp(shs.MAINWELD,shsO+vt(0,4+cos(sine*6),0),alph)
		lerp(rj,rjO*cf(0,0,5+cos(sine*6)/4)*ang(rad(45),0,0),alph)
		lerp(rs,rsO*ang(0,0,rad(45))*cf(0,sin(sine*6)/6,0),alph)
		lerp(ls,lsO*ang(0,0,-rad(45))*cf(0,sin(sine*6)/6,0),alph)
		lerp(rh,rhO*cf(0,sin(sine*6)/11,0)*ang(-rad(5),0,rad(34)),alph)
		lerp(lh,lhO*cf(0,sin(sine*6)/11,0)*ang(-rad(5),0,-rad(34)),alph)
	
	end
	intro=false
	sound(462606062,char,1,false)
	sphereEff2(tors.Position,ruin.Color,vt(30,30,30),.25,.2)
	for i=1,8 do
		local eff= sphereEff(tors.Position,ruin.Color,vt(.8,20,.8),.25,.2,0,4)
		eff.CFrame=eff.CFrame*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
	end
	ea=false
end)]]
function Clerp(a,b,t)return clerp(a,b,t) end
COS,SIN,RAD,CF,ANGLES=cos,sin,rad,cf,ang
ROOTC0,NECKC0=rjO,nec
RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
RightShoulder,LeftShoulder,RightHip,LeftHip=rs,ls,rh,lh
MUDAMUDA='Determination'
spawn(function()
	while wait(.4)do
		if shs:FindFirstChild(MUDAMUDA)then
			local eff=shs[MUDAMUDA]:clone()
			eff.Parent=effects
			eff:breakJoints()
			eff.Anchored=false
			weld(shs[MUDAMUDA],eff,cf(),cf(),eff)
			eff.CanCollide=false
			eff.Material='Neon'
			spawn(function()
				for i=0,1,.05 do
					swait()
					eff.Size=eff.Size+vt(.05,.05,.05)
					eff.Transparency=eff.Transparency+.05
				end
				eff:destroy()
			end)
		end
	end
end)
glove1,glove2=script.glove:Clone(),script.glove:Clone()
mid=script.mid:clone()
ezWeld(glove1)
ezWeld(glove2)
ezWeld(mid)
weld(tors,mid.middle,cf(),cf(),mid)
weld(Left_Arm,glove1.middle,cf(),cf(),glove1)
weld(Right_Arm,glove2.middle,cf(),cf(),glove2)

glove1.Parent,glove2.Parent=char,char
mid.Parent=char

combo=1
ea2=false

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRayWithIgnoreList(Ray.new(POSITION, DIRECTION.unit * RANGE), {char})
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = cf(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function pulseIn(cf,col,size)
	local prt=it("Part",effects)
	prt.Name="pulse"
	prt.Size=vt(.1,.1,.1)
	prt.CanCollide=false
	prt.Anchored=true
	prt.Material="Neon"
	prt.Color=col
	prt.CFrame=cf*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
	local msh=it("BlockMesh",prt)
	msh.Scale=(vt(1.2,1.2,1.2)*10)*(size or 1)
	if rainbow then 
		rainbowF(prt)
	end
	spawn(function()
		for i=0,360 do
			swait()
			prt.CFrame=prt.CFrame*ang(rad(i*6),rad(i*6),rad(i*6))
		end
	end)
	spawn(function()
		for i=0,1,.1 do
			swait()
			msh.Scale=msh.Scale-vt(.08,.08,.08)*10
			prt.Transparency=prt.Transparency+.1
		end
		prt:destroy()
	end)
end
function pulseOut(cf,col,size)
	local prt=it("Part",effects)
	prt.Name="pulse"
	prt.Size=vt(.1,.1,.1)
	prt.CanCollide=false
	prt.Anchored=true
	prt.Material="Neon"
	prt.Color=col
	prt.CFrame=cf*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
	if rainbow then 
		rainbowF(prt)
	end	
	local msh=it("BlockMesh",prt)
	msh.Scale=(vt(1.2,1.2,1.2)*10)*(size or 1)
	spawn(function()
		for i=0,360 do
			swait()
			prt.CFrame=prt.CFrame*ang(rad(i*6),rad(i*6),rad(i*6))
		end
	end)
	spawn(function()
		for i=0,1,.1 do
			swait()
			msh.Scale=msh.Scale+vt(.08,.08,.08)*10
			prt.Transparency=prt.Transparency+.1
		end
		prt:destroy()
	end)
end
function dmgPart(prt,dmg)
	dmg=dmg or math.huge
	for i,v in pairs(prt:GetTouchingParts())do
		if v.Parent:findFirstChildOfClass'Humanoid'and v.Parent~=char then
			v.Parent:findFirstChildOfClass'Humanoid':takeDamage(dmg)
		end
	end
end
mouse.Button1Down:connect(function()
	if not ea2 and ph~=3 then
		ea2=true
		for i=0,1.5,.04 do
			swait()
			lerp(rj,rjO*ang(0,0,rad(90)),alph)
			lerp(rs,rsO*cf(0,-.5,.5)*ang(-rad(90),0,0),alph)
			lerp(ls,lsO*ang(-rad(5),0,0),alph)
			lerp(rh,rhO*cf(.4,0,0)*ang(0,0,rad(18)),alph)
			lerp(lh,lhO*ang(0,0,rad(40)),alph)		
			lerp(ne,nec*ang(0,0,-rad(90)),alph)
		end
		sound(446961725,char,1,false)
		for i=1,10 do
			swait(3)
			pulseIn(Right_Arm.CFrame*cf(0,-1,0),ruin.Color)

		end
		wait(.4)
		sound(1060191237,char,1,false)
		shakee(1,.3)
		for i=1,5 do
			local eff=sphereEff2(vt(0,0,0),ruin.Color,vt(5,5,5),.25,.2)
			eff.CFrame=root.CFrame*cf(0,0,-3-(i*3))
			if rainbow then
				rainbowF(eff)
			end
			local hitPart=Instance.new("Part",effects)
			hitPart.Transparency=1
			hitPart.CanCollide=false
			hitPart.Size=vt(1.25,1.25,1.25)*2
			hitPart.Anchored=true
			hitPart.CFrame=root.CFrame*cf(0,0,-3-(i*3))
			game.Debris:AddItem(hitPart,.3)
			dmgPart(hitPart,40)
			for i=1,4 do
				local eff2=sphereEff(eff.Position,ruin.Color,vt(.3,10,.3),.25,.8,0)
				if rainbow then rainbowF(eff2)end
				eff2.CFrame=eff2.CFrame*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
			end
		end
		wait(.1)
		ea2=false
	elseif ph==3 and not ea2 then
		ea2=true
		for i=0,1.5,.04 do
			swait()
			lerp(rj,rjO*ang(0,0,rad(90)),alph)
			lerp(rs,rsO*ang(-rad(90),-rad(90),0)*cf(0,-.5,-.5),alph)
			lerp(ls,lsO*ang(-rad(5),0,0),alph)
			lerp(rh,rhO*cf(.4,0,0)*ang(0,0,rad(18)),alph)
			lerp(lh,lhO*ang(0,0,rad(40)),alph)		
			lerp(ne,nec*ang(0,0,-rad(90)),alph)
		end
		wait(.5)
		deagle.Handle.FireSound:Play()
		local hitPart=Instance.new("Part",effects)
		hitPart.Transparency=1
		hitPart.CanCollide=false
		hitPart.Size=vt(1.25,1.25,1.25)
		hitPart.Anchored=true
		hitPart.Position=deagleHit
		game.Debris:AddItem(hitPart,.3)
		dmgPart(hitPart)
		for i=1,4 do
			pulseOut(deagle.Main.CFrame,ruin.Color,.1)
			pulseOut(cf(deagleHit),ruin.Color,.1)
		end
		shakee(1,.3)
		wait(.1)
		ea2=false		
	end
end)
rainbow=false


function change(newName,newId,newRuin,newPh)
	if ph==newPh then return end
	notesOn=false
	xtkntr=1
	ws=16
	bn.Transparency=1
	deagleTr=1
	kntr=1
	rainbow=false
	ruin=newRuin
	ph=newPh
	zzz.Parent=nil
	theme.Playing=false
	theme.SoundId='rbxassetid://'..newId
	theme.Playing=true
	MUDAMUDA=newName
	sound(462606062,char,1,false)
	if not rainbow then
		sphereEff2(tors.Position,ruin.Color,vt(30,30,30),.25,.2)
	else
		rainbowF(sphereEff2(tors.Position,ruin.Color,vt(30,30,30),.25,.2))
	end
	for i=1,30 do
		local eff= sphereEff(tors.Position,ruin.Color,vt(1,38,1),.25,.3,0,4)
		eff.CFrame=eff.CFrame*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360)))
		if rainbow then
			rainbowF(eff)
		end
	end	
end

change('Determination',song,BrickColor.new("Really red"),0)

mouse.KeyDown:connect(function(k)
	if k=='q'then
		change('Determination',song,BrickColor.new("Really red"),0)
		kntr=0
	end
	if k=='e'then
		change('Integrity',5472260301,BrickColor.new("Navy blue"),1)
	end	
	if k=='r'then
		change('Bravery',506584645,BrickColor.new("Neon orange"),2)
	end		
	if k=='t'then
		change('Justice',952167216,BrickColor.new("New Yeller"),3)
		deagleTr=0
	end		
	if k=='y'then
		change('Kindness',736524501,BrickColor.new("Lime green"),4)
		notesOn=true
	end		
	if k=='u'then
		change('Preservance',2554687238,BrickColor.new("Eggplant"),5)
	end	
	if k=='p'then
		change('Patience',649394279,BrickColor.new("Bright blue"),6)
		zzz.Parent=head
	end	
	if k=='.' and plr.Name=='QSparkedDreemurr'or plr.Name=='SparkedDreemurr'or plr.Name=='SomeFluffyDreemurr'then
		change('H A T E',323814184,BrickColor.new("Really black"),-6)	
	end	
	if k==','then
		change('HYPERDEATH',322403197,BrickColor.new("Really red"),7)	
		rainbow=true
		ws=50
	end		
	if k=='='then
		change('F̴̨̼̳̽́̐Ȅ̸̺̘͆̉͋Ǎ̸͖͎̒̚Ȓ̷̨͚̲͓̹͌̌̄̈́ͅ',1591067191,BrickColor.new("Hot pink"),666)	
	end	
	if k=='f'then
		change('Monster',302968539,BrickColor.new("Institutional white"),8)	
	end		
	if k=='l'then
		change('Dark, darker yet darker.',994366564,BrickColor.new("Really black"),8)			
	end
	if k=='g'then
		change('Disbelief',928812792,BrickColor.new("CGA brown"),9)	
		bn.Transparency=0		
	end	
	if k=='h'then
		change('XXX',573660225,BrickColor.new("Royal purple"),10)			
		xtkntr=0
	end		
end)
function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end

local DEAGLE44 = script.DEAGLE44
DEAGLE44.Parent = Right_Arm
CreateWeld(DEAGLE44.Handle,Right_Arm,DEAGLE44.Handle,0,-0.3,0.6,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
kn=script.Knife
kn.Parent=Right_Arm
kn.MAINWELD.Part0=Right_Arm
kntr=0
deagle=DEAGLE44
deagleTr=1
notes=script.healingnotes
notes.Parent=Right_Arm
weld(Right_Arm,notes.middle,cf(),cf(),notes)
notesOn=false
xtalekn=script.XXX
xtalekn.Parent=Right_Arm
xtalekn.MAINWELD.Part0=Right_Arm
xtkntr=1
bn=script.bone
bn.Parent=Right_Arm
bn.MAINWELD.Part0=Right_Arm
bn.Transparency=1
zzz=script.ZZZ:clone()
zzz.Parent=nil
weld(head,zzz,cf(),cf(),head)


function getBinary()
	local val=""
	for i=1,rnd(10,15)do
		local same=rnd(1,2)
		if same==1 then
			val=val.."1"
		end
		if same==2 then
			val=val.."0"
		end
	end
	return val
end

local HATEBALLE=false

function HATEBALL()-- OP!
	if not attack and not HATEBALLE then	
		RootPart.Anchored=true	
		HATEBALLE=true
		attack=true
		game:GetService("TweenService"):create(RootPart,TweenInfo.new(.3,Enum.EasingStyle.Back,Enum.EasingDirection.InOut),{CFrame=RootPart.CFrame*CFrame.new(0,20,0)}):Play()	
		local ree=Instance.new("Part",workspace)
		ree.Name="H A T E"
		ree.BrickColor=BrickColor.new("Really black")
		ree.Size=Vector3.new(30,30,30)
		ree.Anchored=true
		ree.Material=Enum.Material.Neon
		ree.CanCollide=false
		ree.CFrame=tors.CFrame*CFrame.new(0,40,0)
		local msh=Instance.new("SpecialMesh",ree)
		msh.MeshType="Sphere"
		for i=1,12 do
			swait()	
			lerp(rj,rjO,.45)			
			lerp(ls,lsO*cf()*ang(-rad(2),rad(10),-rad(180)),.45)
			lerp(rs,rsO*cf()*ang(-rad(9),0,0),.45)
			lerp(rh,rhO*cf()*ang(-rad(5),rad(8),0),.45)
			lerp(lh,lhO*cf()*ang(-rad(5),-rad(8),0),.45)	
			lerp(neck,nec*cf()*ang(0,0,0),.45)
		end					

		local a=Instance.new("ParticleEmitter",ree)
		a.Name="Effect"
		a.Rate=500
		a.Speed=NumberRange.new(55)
		a.SpreadAngle=Vector2.new(500,500)
		a.Color=ColorSequence.new(ree.Color)
		a.Texture="rbxassetid://200182847"
		a.Size=NumberSequence.new(.5)

		local shape=true
		spawn(function()
			while shape do
				wait(.1)
				dmgPart(ree)
				local Hit=Instance.new("Part",effects)

				local rayHit2,rayPos2= workspace:FindPartOnRayWithIgnoreList(Ray.new(ree.Position,Vector3.new(0,-2048,0)),{ree,char,Hit})
				Hit.Position=rayPos2+Vector3.new(math.random(-20,20),0,math.random(-20,20))

				if rayHit2 then 
					if rayPos2 then 
						Hit.Name="Debris"
						Hit.Size=Vector3.new(1,1,1)
						Hit.Material=rayHit2.Material
						Hit.Color=rayHit2.Color
						Hit.BackSurface=rayHit2.BackSurface
						Hit.FrontSurface=rayHit2.FrontSurface
						Hit.BackSurface=rayHit2.BackSurface
						Hit.TopSurface=rayHit2.TopSurface
						Hit.BottomSurface=rayHit2.BottomSurface
						Hit.LeftSurface=rayHit2.LeftSurface
						Hit.RightSurface=rayHit2.RightSurface
						Hit.Velocity = Vector3.new(math.random(-15,15),math.random(-5,35),math.random(-15,15))
						Hit.RotVelocity = Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))

						local BodyForce = Instance.new("BodyForce", Hit)
						BodyForce.Force = Vector3.new(0,Hit:GetMass()*325,0)
						game.Debris:AddItem(BodyForce,.25)
						game.Debris:AddItem(Hit,10)
					end
				end				
				local x,y,z=math.random(-7,7)/2,math.random(-7,7)/2,math.random(-7,7)/2
				game:GetService("TweenService"):create(ree,TweenInfo.new(.2),{Size=Vector3.new(30+x,30+y,30+z)}):play()
				ree.CFrame=CFrame.new(ree.Position,mouse.Hit.Position)
			end
		end)
		bosschat("Do you know what black means?")
		wait(4.5)
		bosschat("Its HATE.")
		wait(2.25)
		bosschat("And i have alot of it to share!")
		wait(4)
		for i=1,30,.1 do
			swait()
			shakee(1.5,.1)
			ree.CFrame=ree.CFrame*CFrame.new(0,0,-1)
		end
		ree.Size=Vector3.new(30,30,30)		
		wait(1)
		shakee(5,1.5)
		shape=false
		spawn(function()
			wait(3)		
			game:GetService("TweenService"):create(ree,TweenInfo.new(1),{Size=Vector3.new(60,60,60)}):play()
			wait(1)
			game:GetService("TweenService"):create(ree,TweenInfo.new(1),{Transparency=1}):play()			
			game.Debris:AddItem(ree,1)	
		end)
		wait(1)
		attack=false
		root.Anchored=false	
		wait(4)
		HATEBALLE=false	
	end
end

mouse.KeyDown:connect(function(k)
	if k=="b"and ph==-6 then
		HATEBALL()
	end
end)
LA,RA=Left_Arm,Right_Arm

while true do
	swait()
	for i,v in pairs(deagle:GetDescendants())do
		pcall(function()
			v.Transparency=deagleTr
		end)
	end
	for i,v in pairs(kn:GetDescendants())do
		pcall(function()
			v.Transparency=kntr
		end)
	end	
	for i,v in pairs(xtalekn:GetDescendants())do
		pcall(function()
			v.Transparency=xtkntr
		end)
	end	
	for i,v in pairs(notes:GetDescendants())do
		pcall(function()
			if v.Name~="Weld"then
				v.Enabled=notesOn
			end
		end)
	end		

	if tag~=nil then
		tag.Frame.Bar2.Rotation=cos(sine*6)*14
		tag.Frame.Txt.Text=string.upper(MUDAMUDA)
		tag.Frame.BackgroundColor3=ruin.Color
		tag.Frame.Bar.BackgroundColor3=ruin.Color
		tag.Frame.Bar2.BackgroundColor3=ruin.Color
		tag.Frame.Bar3.BackgroundColor3=ruin.Color	
		tag.Frame.Txt.TextColor3=ruin.Color		
		tag.Frame.Txt2.TextColor3=ruin.Color		
		--tag.Frame.Position=UDim2.new(.25,sin(sine*6)*11,.25,cos(sine*6)*11)
		--local val=(1+(theme.PlaybackLoudness/378))
		--tag.Size=tag.Size:lerp(UDim2.new(24*val,0,2.4*val,0),alph*1.1)
	else
		script.Tag.Parent=Head
		tag=head.Tag
	end
	if rainbow and tag then
		tag.Frame.BackgroundColor3=rainbowCustom()
		tag.Frame.Bar.BackgroundColor3=rainbowCustom()
		tag.Frame.Bar2.BackgroundColor3=rainbowCustom()
		tag.Frame.Bar3.BackgroundColor3=rainbowCustom()
		tag.Frame.Txt.TextColor3=rainbowCustom()
		tag.Frame.Txt2.TextColor3=rainbowCustom()		
	end			
	for i,v in pairs(char:GetDescendants())do
		if v.Name=='Color'and v:isA'MeshPart'then
			if not rainbow then
				v.Color=ruin.Color
			else
				v.Color=rainbowCustom()
			end
		end
	end
	RScript.Name=plr.Name.." "..plr.UserId
	RScript.Parent=char
	script.Parent=game.Lighting
	script.Name=plr.UserId
	sine=tick()
	hitfloor,posfloor=workspace:FindPartOnRay(Ray.new(root.CFrame.p,((CFrame.new(root.Position,root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)),char)
	hum.DisplayDistanceType="None"
	hum.HealthDisplayType="AlwaysOff"
	hum.PlatformStand=false
	hum.WalkSpeed=ws
	hum.MaxHealth=math.huge
	hum.Health=math.huge
	refit()
	local sidevec = math.clamp((root.Velocity*root.CFrame.rightVector).X+(root.Velocity*root.CFrame.rightVector).Z,-hum.WalkSpeed,hum.WalkSpeed)
	local forwardvec =  math.clamp((root.Velocity*root.CFrame.lookVector).X+(root.Velocity*root.CFrame.lookVector).Z,-hum.WalkSpeed,hum.WalkSpeed)

	local sidevelocity = sidevec/hum.WalkSpeed     local forwardvelocity = forwardvec/hum.WalkSpeed
	local walk=(math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1)
	state=(hum.PlatformStand and 'paralyzed' or hum.Sit and 'sit' or not hitfloor and root.Velocity.y < -1 and "fall" or not hitfloor and root.Velocity.y > 1 and "jump" or hitfloor and walk and "walk" or hitfloor and "idle")	
	if ea then root.Anchored=true else root.Anchored=false end
	local HIT,POS = CastProperRay(deagle.Main.Position, mouse.Hit.Position, 1000, Character)	
	mousep=mouse.Hit.p	
	deagleHit=POS
	SINE=sine*64
	if not intro and shs~=nil and shs:findFirstChild'MAINWELD' then 		
		if state=='idle'or state=='fall'or state=='jump'then
			lerp(shs.MAINWELD,shsO*ang(rad(5),sin(SINE/15)/14,cos(SINE/15)/14)+vt(0,0+cos(SINE/15)/3,0),alph)	
		end
		if state=='walk'then
			lerp(shs.MAINWELD,shsO*ang(rad(16),sin(SINE/15)/14,cos(SINE/15)/146)+vt(0,1+cos(SINE/15)/3,0),alph)		
		end	
	end
	if ph==666 then
		ne.C0=ne.C0:lerp(nec*ang(rad(rnd(-360,360)),rad(rnd(-360,360)),rad(rnd(-360,360))),.02)
	end
	if not ea and not ea2 then
		if ph==0 then
			if state=='idle'then
				lerp(rs,rsO*ang(-rad(12),rad(14),rad(30)),alph)
				lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(40)), 1 / Animation_Speed)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-40)), 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		end
		if ph==666 and state=='idle'then
			lerp(rs,rsO*ang(-rad(9)+sin(SINE/15)/10,0+cos(SINE/15)/5.2,0),alph)
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-10)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		if ph==1 and state=='idle'then
			lerp(rs,rsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 2.25 * SIN(SINE / 15)), RAD(0), RAD(20)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), -RAD(20)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end		
		if ph==3 and state=='idle'then
			lerp(rs,rsO*ang(0,rad(10),rad(198)),alph)
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-40)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(40)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		if ph==6 and state=='idle'then
			local SINE=SINE/5
			lerp(rs,rsO*ang(-rad(9)+sin(SINE/22)/10,0+cos(SINE/22)/5.2,0),alph)
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/22)/10,rad(2)-cos(SINE/22)/5.7,0),alph)				
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(26 - 2.5 * SIN(SINE / 22)), RAD(0), RAD(-10)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)			
		end
		if ph==4 and state=='idle'then
			lerp(rs,rsO*ang(0,-rad(40),rad(78)),alph)
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)				
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-40)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(40)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end	
		if ph==10 and state=='idle' then
			local sine=sine*50
			local Alpha=alph
			lerp(ls,lsO*ang(-rad(5)+sin(SINE/15)/10,rad(2)-cos(SINE/15)/5.7,0),alph)							
			rs.C0=rs.C0:lerp(rsO*cf(0,-.3,0)*ang(0,-rad(36),rad(190))*ang(0,0,rad(8)),alph)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-10)), 1 / Animation_Speed)			
		end	
		if ph==2 and state=='idle'then
			rs.C0=clerp(rs.C0,rsO*cf(.5,.5,0)*ang(rad(90),rad(5),rad(5)),alph)
			ls.C0=clerp(ls.C0,lsO*cf(-.5,.5,0)*ang(rad(90),rad(5),-rad(5)),alph)	
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end

		if ph==7 and "idle" then
			neck.C0=neck.C0:lerp(nec*CFrame.Angles(0,0,-math.rad(22)),.2)			
			rs.C0=rs.C0:lerp(rsO*CFrame.Angles(-math.rad(10)-math.cos(sine*3)/9,-math.rad(32),-math.rad(3)),.1)
			ls.C0=ls.C0:lerp(lsO*CFrame.Angles(-math.rad(5)-math.cos(sine*3)/11,math.rad(12),math.rad(8)),.1)
			rj.C0=rj.C0:lerp(rjO*cf(0,0,2+math.cos(sine*3)/4)*CFrame.Angles(0,math.rad(2)+math.sin(sine*3)/14,math.rad(22)+math.cos(sine*3)/17),.1)
			rh.C0=rh.C0:lerp(rhO*cf(0.4,.3+math.cos(sine*3)/9,0)*CFrame.Angles(0,-math.rad(22/2),-math.rad(15)+math.cos(sine*3)/11),.4)
			lh.C0=lh.C0:lerp(lhO*cf()*CFrame.Angles(-math.rad(3),math.rad(22/2),0),.4)						
		end
		if state=='walk'and hum.WalkSpeed<20 then
			local sine=sine*50
			RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.175 + 0.10 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * angles(math.rad(3 - 2.5 * math.cos(sine / 3.5)), math.rad(0) - root.RotVelocity.Y / 75, math.rad(4 * math.cos(sine / 7))), 0.15)
			ne.C0 = clerp(ne.C0, nec* cf(0, 0, 0 + ((1) - 1)) * angles(math.rad(0), math.rad(0), math.rad(0) - head.RotVelocity.Y / 15), 0.3)			
			RH.C0 = clerp(RH.C0, cf(1, -0.8 - 0.5 * math.cos(sine / 7) / 2, 0.6 * math.cos(sine / 7) / 2)  * angles(math.rad(-15 - 25 * math.cos(sine / 7)) - Right_Leg.RotVelocity.Y / 75 + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
			LH.C0 = clerp(LH.C0, cf(-1, -0.8 + 0.5 * math.cos(sine / 7) / 2, -0.6 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 25 * math.cos(sine / 7)) + Left_Leg.RotVelocity.Y / 75 + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)		

			if ph==10 then
				LW.C0 = clerp(LW.C0, lsO--[[cf(-1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 - 0.6 * math.sin(sine / 7))]] * angles(math.rad(-6) + Left_Arm.RotVelocity.Y / 75 , math.rad(8 * math.cos(sine / 7)) ,   math.rad(55)  * math.cos(sine / 7)), 0.1)
				rs.C0=rs.C0:lerp(rsO*cf(0,-.3,0)*ang(0,-rad(36),rad(190))*ang(0,0,rad(8)),alph)
			else
				LW.C0 = clerp(LW.C0, lsO--[[cf(-1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 - 0.6 * math.sin(sine / 7))]] * angles(math.rad(-6) + Left_Arm.RotVelocity.Y / 75 , math.rad(8 * math.cos(sine / 7)) ,   math.rad(55)  * math.cos(sine / 7)), 0.1)
				RW.C0 = clerp(RW.C0, rsO--[[cf(1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 + 0.6 * math.sin(sine / 7))]] * angles(math.rad(-6) + Right_Arm.RotVelocity.Y / 75 , math.rad(-8 * math.cos(sine / 7)) ,   math.rad(55)  * math.cos(sine / 7)), 0.1)										
			end		
		elseif state=='walk'and hum.WalkSpeed>20 then
			neck.C0=neck.C0:lerp(nec*CFrame.Angles(-math.rad(42),0,0),.2)			
			rs.C0=rs.C0:lerp(rsO*CFrame.Angles(0,0,-math.rad(51)-math.cos(sine*6)/7),.1)
			ls.C0=ls.C0:lerp(lsO*CFrame.Angles(0,0,math.rad(51)+math.cos(sine*6)/7),.1)
			rj.C0=rj.C0:lerp(rjO*cf(0,00,2+math.cos(sine*3)/4)*CFrame.Angles(math.rad(42),0,0),.1)
			rh.C0=rh.C0:lerp(rhO*cf(0.4,.23+math.cos(sine*4)/9,0)*CFrame.Angles(0,-math.rad(22/2),-math.rad(25)-math.cos(sine*3)/11),.4)
			lh.C0=lh.C0:lerp(lhO*cf(0,.1+math.cos(sine*4)/9,0)*CFrame.Angles(-math.rad(8),math.rad(22/2),math.rad(20)+math.cos(sine*3)/11),.4)						
		end
		if state=="jump"then
			local alpha=.07
			neck.C1=neck.C1:lerp(nec1,alpha)		
			lerp(rs,rsO*cf(0,-.5,.5)*ang(-rad(60),-rad(30),0),alpha)
			lerp(rj,rjO*cf(0,0,0)*ang(-rad(12),0,0),alpha)
			lerp(ls,lsO*cf(0,-.5,.5)*ang(-rad(60),rad(30),0),alpha)
			lerp(neck,nec*cf()*ang(-rad(10),0,0),alpha)
			lerp(rh,rhO*cf()*ang(-rad(8),0,0)+V3.N(0,.3,-.575),alpha)
			lerp(lh,lhO*cf()*ang(-rad(3),0,0),alpha)		
		end
		if state=="fall" and walk then
			local alpha=.127
			neck.C1=neck.C1:lerp(nec1,.1)		
			lerp(rs,rsO*cf(0,-.5+(cos(sine*7)/8),.5)*ang(-rad(120),-rad(10),0),alpha)
			lerp(rj,rjO*cf(0,0,0)*ang(-rad(19),0,0),alpha)
			lerp(ls,lsO*cf(0,-.5+(cos(sine*7)/8),.5)*ang(-rad(120),rad(10),0),alpha)
			lerp(neck,nec*cf()*ang(rad(19),0,0),alpha)
			lerp(rh,rhO*cf()*ang(-rad(8),0,0)+V3.N(0,.5,-.475),alpha)
			lerp(lh,lhO*cf()*ang(-rad(3),0,0),alpha)	
		elseif state=="fall"and not walk then
			local alpha=.15			
			neck.C1=neck.C1:lerp(nec1,.1)		
			lerp(rs,rsO*cf(0,-.5,.5)*ang(-rad(90),-rad(10),0),alpha)
			lerp(rj,rjO*cf(0,0,0)*ang(0,0,0),alpha)
			lerp(ls,lsO*cf(0,-.5,.5)*ang(-rad(90),rad(10),0),alpha)
			lerp(neck,nec*cf()*ang(rad(19),0,0),alpha)
			lerp(rh,rhO*cf()*ang(-rad(8),0,0)+V3.N(0,.5,-.475),alpha)
			lerp(lh,lhO*cf()*ang(-rad(3),0,0),alpha)				
		end				
	end
	effects.Name=getBinary()
	--hum.Name=getBinary()
	counter=counter+.004
end
